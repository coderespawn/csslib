// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

library generate;

import 'dart:collection';

import 'package:csslib/parser.dart';
import 'package:csslib/visitor.dart';

/**
 * Each CSS selector has an entry in the computeClassSelectors map.  The entry
 * is ordered by CSS class selector name and it maps to the CssData which has
 * the priority (order in the CSS file) and the list of Dart CSS styles to be
 * emitted in the generated Dart style class.
 */
class CssData {
  /** Style priority based on source order. */
  int priority;
  /** Styles associated with this class selector. */
  List dartStyles = [];

  CssData([this.priority]);
}

class Generate {
  // Build up list of all known class selectors in all CSS files.
  static SplayTreeMap<String, CssData> computeClassSelectors(RuleSet ruleset,
      SplayTreeMap<String, CssData> classes) {
    for (final selector in ruleset.selectorGroup.selectors) {
      final selSeqs = selector.simpleSelectorSequences;
      final int selSeqsLen = selSeqs.length;
      for (var idx = 0; idx < selSeqsLen ; idx++) {
        final selSeq = selSeqs[idx];
        final nextSelSeq = ((idx + 1) < selSeqsLen) ?
            selSeqs[idx + 1].simpleSelector : null;
        final simpleSelector = selSeq.simpleSelector;
        if (simpleSelector is ClassSelector) {
          String className = simpleSelector.name;

          // Never use any Dart styles in a pseudo class selector (e.g.,
          // .foo:before), and if the class name (sans pseudo class) already
          // exists; we're done with this class selector.
          if ((nextSelSeq != null && nextSelSeq is PseudoClassSelector) &&
              classes.containsKey(className)) {
            // TODO(terry): Verify that pseudo classes (:hover, etc.) don't
            //              contain banned properties.  E.g, :hover shouldn't
            //              change the size of a view, etc
            continue;
          }

          /** [dartStyles] list of styles mapped to this className. */
          var cssClass = classes.putIfAbsent(className,
              () => new CssData(classes.length));

          final decls = ruleset.declarationGroup.declarations;
          for (Declaration decl in decls) {
            if (decl.hasDartStyle) {
              bool replaced = false;
              var newStyle = decl.dartStyle;
              for (var i = 0; i < cssClass.dartStyles.length; i++) {
                final dartStyle = cssClass.dartStyles[i];
                if (dartStyle.isSame(newStyle)) {
                  var mergedExpression = dartStyle.merged(newStyle);
                  if (mergedExpression != null) {
                    cssClass.dartStyles[i] = mergedExpression;
                    replaced = true;
                  }
                }
              }
              if (!replaced) {
                cssClass.dartStyles.add(newStyle);
              }
            }
          }
        }
      }
    }

    return classes;
  }

  /**
   * Map a CSS class selector name that has hypens.  Remove the hyphen and
   * capitalize the next character.
   */
  static String classSelectorToDartName(String className) {
    StringBuffer dartName;
    List classParts = className.split('-');
    for (String part in classParts) {
      if (dartName == null) {
        dartName = new StringBuffer(part);
      } else {
        dartName.add(part[0].toUpperCase());
        dartName.add(part.substring(1));
      }
    }

    return dartName.toString();
  }

  static String dartClass(StyleSheet stylesheet, String filename,
                          String libName) {
    var knownClasses = new SplayTreeMap<String, CssData>();

    StringBuffer buff = new StringBuffer(
        "// File generated by Dart CSS tool from source file $filename.\n"
        "// This library is intended to be imported via a prefix.\n"
        "// Do not edit.\n\n"

        "library $libName;\n"
        "import 'package:web_components/src/styleimpl/styleimpl.dart';\n\n");

    // Find all known classes.
    for (final production in stylesheet._topLevels) {
      if (production is IncludeDirective) {
        for (final topLevel in production.styleSheet._topLevels) {
          if (topLevel is RuleSet) {
            knownClasses = computeClassSelectors(topLevel, knownClasses);
          }
        }
      } else if (production is RuleSet) {
        knownClasses = computeClassSelectors(production, knownClasses);
      }
    }

    // Generate all known classes encountered in all processed CSS files.
    for (final className in knownClasses.keys) {
      String classAsDart = classSelectorToDartName(className);
      var cssData = knownClasses[className];
      var dartStyles = cssData.dartStyles;
      var order = cssData.priority;
      buff.add('final $classAsDart = const Style(\'$className\',$order');
      if (dartStyles != null) {
        for (var dartStyle in dartStyles) {
          buff.add(',');
          if (dartStyle.isFont) {
            // TODO(terry): Consider putting this code into FontExpression's
            //              toString.
            bool anyParam = false;
            Font font = dartStyle.font;
            buff.add('font: const Font(');
            if (font.family != null && font.family.length > 0) {
              buff.add('family: const [');
              for (var name in font.family) {
                // TODO(terry): Shouldn't need to check for quoted string; fix
                //              tokenizer.
                if (name.startsWith('"')) {
                  buff.add('$name,');
                } else {
                  buff.add('\"$name\",');
                }
              }
              buff.add(']');
              anyParam = true;
            }
            if (font.weight != null) {
              if (anyParam) {
                buff.add(',');
              }
              buff.add('weight: ${font.weight}');
              anyParam = true;
            }
            if (font.size != null) {
              if (anyParam) {
                buff.add(',');
              }
              buff.add('size: ${font.size}');
              anyParam = true;
            }
            if (font.lineHeight != null) {
              if (anyParam) {
                buff.add(',');
              }
              buff.add('lineHeight: const LineHeight('
                       '${font.lineHeight.height},'
                       'inPixels: ${font.lineHeight.inPixels})');
              anyParam = true;
            }
            buff.add(')');
          } else if (dartStyle.isBoxExpression) {
            // border, margin or padding; emit name : const BoxEdge (e.g.,
            // "border : const BoxEdge".
            buff.add(dartStyle);
          } else if (dartStyle.isHeight) {
            buff.add('height:${dartStyle.height}');
          } else if (dartStyle.isWidth) {
            buff.add('width:${dartStyle.width}');
          } else {
            // TODO(terry): More DartStyles for emitting...
          }
        }
      }

      buff.add(');\n');
    }

    return buff.toString();
  }
}

